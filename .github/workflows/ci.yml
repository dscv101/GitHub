name: CI

on:
  push:
    branches: [ main ]
  pull_request:

permissions:
  contents: read
  issues: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  flake-check:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          install_url: https://releases.nixos.org/nix/nix-2.31.0/install
          extra_nix_config: |
            experimental-features = nix-command flakes
            substituters = https://cache.nixos.org/ https://nix-community.cachix.org
            trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=

      - name: Check flake
        run: |
          nix flake check --show-trace --verbose || {
            echo "Flake check failed, attempting to show more details..."
            nix flake show || echo "Could not show flake outputs"
            exit 1
          }

      - name: Build NixOS configuration
        run: |
          nix build .#nixosConfigurations.blazar.config.system.build.toplevel --show-trace --verbose || {
            echo "Build failed, checking if configuration exists..."
            nix flake show | grep -A 10 nixosConfigurations || echo "No nixosConfigurations found"
            exit 1
          }

  code-quality:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          install_url: https://releases.nixos.org/nix/nix-2.31.0/install
          extra_nix_config: |
            experimental-features = nix-command flakes
            substituters = https://cache.nixos.org/ https://nix-community.cachix.org
            trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=

      - name: Check code formatting (treefmt)
        run: |
          nix build .#checks.x86_64-linux.treefmt || {
            echo "treefmt check not available, skipping..."
            exit 0
          }

      - name: Check code formatting (alejandra fallback)
        run: |
          nix develop --command alejandra --check . || {
            nix develop --command alejandra --check . 2>&1 || true
            exit 1
          }

      - name: Check for dead code
        run: nix develop --command deadnix --fail --exclude flake.nix .

      - name: Run static analysis
        run: nix develop --command statix check .

      - name: Check shell scripts
        run: |
          if [ -d "scripts" ] && [ -n "$(find scripts -name '*.sh' 2>/dev/null)" ]; then
            nix develop --command shellcheck scripts/*.sh || echo "Warning: shellcheck failed for scripts"
          fi
          if [ -d "modules/nixos/hardware/scripts" ] && [ -n "$(find modules/nixos/hardware/scripts -name '*.sh' 2>/dev/null)" ]; then
            nix develop --command shellcheck modules/nixos/hardware/scripts/*.sh || echo "Warning: shellcheck failed for hardware scripts"
          fi

      - name: Check shell script formatting
        run: |
          if [ -d "scripts" ] && [ -n "$(find scripts -name '*.sh' 2>/dev/null)" ]; then
            nix develop --command shfmt -d scripts/*.sh || echo "Warning: shfmt failed for scripts"
          fi
          if [ -d "modules/nixos/hardware/scripts" ] && [ -n "$(find modules/nixos/hardware/scripts -name '*.sh' 2>/dev/null)" ]; then
            nix develop --command shfmt -d modules/nixos/hardware/scripts/*.sh || echo "Warning: shfmt failed for hardware scripts"
          fi

      - name: Lint Markdown files
        run: |
          if [ -n "$(find . -maxdepth 1 -name '*.md' 2>/dev/null)" ]; then
            nix develop --command markdownlint ./*.md || echo "Warning: markdownlint failed"
          else
            echo "No Markdown files found to lint"
          fi

      - name: Lint YAML files
        run: |
          nix develop --command yamllint . || echo "Warning: yamllint failed"

      - name: Lint GitHub Actions
        run: |
          nix develop --command actionlint || echo "Warning: actionlint failed"

  test-dependency-updates:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [ flake-check, code-quality ]
    if: ${{ github.event_name == 'pull_request' && contains(github.head_ref, 'automated-deps-update') }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          install_url: https://releases.nixos.org/nix/nix-2.31.0/install
          extra_nix_config: |
            experimental-features = nix-command flakes
            substituters = https://cache.nixos.org/ https://nix-community.cachix.org
            trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=

      - name: Extended testing for dependency updates
        run: |
          nix build .#nixosConfigurations.blazar.config.system.build.toplevel
          # nix build .#checks.x86_64-linux.integration-tests || true

  # --- New: open/update an issue when the workflow fails ---
  report-ci-failure:
    runs-on: ubuntu-latest
    needs: [ flake-check, code-quality, test-dependency-updates ]
    if: ${{ failure() }}   # only run if any dependency failed
    steps:
      - name: Create CI failure report (Markdown)
        id: mk
        run: |
          cat > ci-failure.md <<'MD'
          <!-- [CI Failure Report] -->
          # ⚠️ CI Failure Report

          **Workflow:** ${{ github.workflow }}
          **Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          **Ref:** `${{ github.ref }}`

          ## Job Results
          - flake-check: `${{ needs.flake-check.result }}`
          - code-quality: `${{ needs.code-quality.result }}`
          - test-dependency-updates: `${{ needs.test-dependency-updates.result }}`

          _This issue is opened/updated automatically._
          MD
          echo "path=ci-failure.md" >> "$GITHUB_OUTPUT"
          echo "title=CI failed: ${{ github.workflow }} on ${GITHUB_REF_NAME }}" >> "$GITHUB_OUTPUT"

      - name: Find existing CI failure issue (by title)
        id: find
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const title = `CI failed: ${context.workflow} on ${process.env.GITHUB_REF_NAME}`;
            const { data } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} is:issue is:open in:title "${title}"`
            });
            core.setOutput('issue-number', (data.items[0]?.number || ''));
            core.setOutput('title', title);

      - name: Create or update Issue from file
        id: issue
        uses: peter-evans/create-issue-from-file@v5
        with:
          title: ${{ steps.find.outputs.title }}
          content-filepath: ${{ steps.mk.outputs.path }}
          labels: ci, automated
          issue-number: ${{ steps.find.outputs.issue-number }}

      - name: Create or update status comment on the issue
        # Tag the comment so we can overwrite it on the next failure
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ steps.issue.outputs.issue-number }}
          body: |
            <!-- ci-failure-comment -->
            ✅ Issue updated for failed run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - flake-check: `${{ needs.flake-check.result }}`
            - code-quality: `${{ needs.code-quality.result }}`
            - test-dependency-updates: `${{ needs.test-dependency-updates.result }}`
          edit-mode: replace
          comment-tag: ci-failure-comment
