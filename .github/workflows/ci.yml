name: CI

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

# SECURITY: Minimal permissions, explicit per-job
permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  # SECURITY: Secure Nix evaluation
  NIX_CONFIG: |
    extra-experimental-features = nix-command flakes
    sandbox = true
    max-jobs = auto

jobs:
  # Detect changed files for conditional execution
  changes:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      nix-files: ${{ steps.changes.outputs.nix-files }}
      docs: ${{ steps.changes.outputs.docs }}
      workflows: ${{ steps.changes.outputs.workflows }}
      scripts: ${{ steps.changes.outputs.scripts }}
      configs: ${{ steps.changes.outputs.configs }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Detect changes
        id: changes
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            base_sha="${{ github.event.pull_request.base.sha }}"
            head_sha="${{ github.event.pull_request.head.sha }}"
          else
            # For push events, compare with previous commit
            base_sha="${{ github.event.before }}"
            head_sha="${{ github.sha }}"
          fi
          
          # If base_sha is empty or all zeros (initial commit), compare with HEAD~1
          if [[ -z "$base_sha" || "$base_sha" == "0000000000000000000000000000000000000000" ]]; then
            base_sha="HEAD~1"
          fi
          
          echo "Comparing $base_sha...$head_sha"
          
          # Check for changes in different file types
          if git diff --name-only "$base_sha" "$head_sha" | grep -E '\.(nix|lock)$' || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "nix-files=true" >> "$GITHUB_OUTPUT"
          else
            echo "nix-files=false" >> "$GITHUB_OUTPUT"
          fi
          
          if git diff --name-only "$base_sha" "$head_sha" | grep -E '\.(md|rst|txt)$|^docs/' || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "docs=true" >> "$GITHUB_OUTPUT"
          else
            echo "docs=false" >> "$GITHUB_OUTPUT"
          fi
          
          if git diff --name-only "$base_sha" "$head_sha" | grep -E '^\.github/workflows/' || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "workflows=true" >> "$GITHUB_OUTPUT"
          else
            echo "workflows=false" >> "$GITHUB_OUTPUT"
          fi
          
          if git diff --name-only "$base_sha" "$head_sha" | grep -E '\.(sh|bash|zsh|fish)$|^scripts/' || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "scripts=true" >> "$GITHUB_OUTPUT"
          else
            echo "scripts=false" >> "$GITHUB_OUTPUT"
          fi
          
          if git diff --name-only "$base_sha" "$head_sha" | grep -E '\.(ya?ml|json|toml)$' || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "configs=true" >> "$GITHUB_OUTPUT"
          else
            echo "configs=false" >> "$GITHUB_OUTPUT"
          fi

  # Combined validation and checks with matrix strategy
  validate-and-check:
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.nix-files == 'true'
    timeout-minutes: 30
    permissions:
      contents: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        check-type: [validate, security, build, checks]
    outputs:
      config-exists: ${{ steps.check-config.outputs.exists }}
      has-checks: ${{ steps.check-config.outputs.has-checks }}
      has-blazar: ${{ steps.check-config.outputs.has-blazar }}
      build-artifact: ${{ steps.build-info.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false

      - name: Install Determinate Nix
        uses: DeterminateSystems/determinate-nix-action@a7e500c712ad97316904566d98013596e868d2fb # v3.11.1

      - name: Setup Magic Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@87b14cf437d03d37989d87f0fa5ce4f5dc1a330b # v8

      - name: Setup devenv cache
        uses: cachix/cachix-action@18cf96c7c98e048e10a83abd92116114cd8504be # v14
        with:
          name: devenv

      - name: Cache devenv shells
        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4.0.2
        with:
          path: |
            ~/.cache/devenv
            ~/.local/share/devenv
          key: devenv-${{ runner.os }}-${{ hashFiles('flake.lock', 'modules/flake/devenvs/**/*.nix') }}
          restore-keys: |
            devenv-${{ runner.os }}-

      - name: Install devenv
        run: nix profile install nixpkgs#devenv

      # SECURITY: Enhanced flake health check (validate only)
      - name: Check flake health
        if: matrix.check-type == 'validate'
        uses: DeterminateSystems/flake-checker-action@078f5f7f47ee188aa6cb472527ca5984e195222d # v9
        with:
          fail-mode: true

      - name: Validate flake structure
        if: matrix.check-type == 'validate'
        id: check-config
        run: |
          echo "üîç Validating flake and configuration..."
          
          # Check flake validity
          if ! nix flake check --show-trace --accept-flake-config; then
            echo "‚ùå Flake check failed"
            exit 1
          fi
          
          # Robustly detect NixOS configurations without forcing full evaluation
          has_configs=$(nix eval --raw --expr 'builtins.hasAttr "nixosConfigurations" (builtins.getFlake ".")' || echo false)
          if [[ "$has_configs" == "true" ]]; then
            echo "config-exists=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ NixOS configurations found"
            echo "Available configs:"
            nix eval --json --expr '(builtins.attrNames (builtins.getFlake ".").nixosConfigurations)' | nix run nixpkgs#jq -- -r '.[]' || true
          else
            echo "config-exists=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è No NixOS configurations found"
          fi
          
          # Check for validation targets
          if nix eval --json .#checks.x86_64-linux >/dev/null 2>&1; then
            echo "has-checks=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Validation checks available"
          else
            echo "has-checks=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è No validation checks found"
          fi
          
          # Check for blazar host configuration
          has_blazar=$(nix eval --raw --expr 'builtins.hasAttr "blazar" (builtins.getFlake ".").nixosConfigurations' || echo false)
          echo "has-blazar=$has_blazar" >> "$GITHUB_OUTPUT"
          if [[ "$has_blazar" == "true" ]]; then
            echo "‚úÖ Blazar host configuration found"
          else
            echo "‚ÑπÔ∏è No blazar host configuration found"
          fi

      # SECURITY: Validate dependencies and inputs
      - name: Security validation
        if: matrix.check-type == 'security'
        run: |
          echo "üîí Running security validation..."
          set -euo pipefail
          # Ensure jq is available via Nix
          if ! command -v jq >/dev/null 2>&1; then
            jq() { nix run nixpkgs#jq -- "$@"; }
          fi
          
          # Check for unsafe Nix features (fail only on allowBroken/allowInsecure)
          if grep -R --include="*.nix" -nE "allowBroken|allowInsecure" . --exclude-dir=".git" 2>/dev/null; then
            echo "‚ö†Ô∏è Unsafe Nix features detected (allowBroken/allowInsecure)"
            exit 1
          fi
          # Note: allowUnfree is acceptable for systems needing proprietary software
          if grep -R --include="*.nix" -nE "allowUnfree" . --exclude-dir=".git" >/dev/null; then
            echo "‚ÑπÔ∏è allowUnfree detected (acceptable for proprietary software support)"
          fi
          
          # Validate flake inputs are from trusted sources  
          nix flake metadata --json > flake-meta.json
          untrusted_count=0
          while read -r owner repo; do
            case "$owner" in
              NixOS|nix-community|cachix|numtide|hercules-ci|Mic92|nlewo|rrbutani|edolstra) 
                echo "‚úÖ Trusted: $owner/$repo" ;;
              *)
                echo "‚ö†Ô∏è Untrusted: $owner/$repo"
                ((untrusted_count++)) ;;
            esac
          done < <(nix run nixpkgs#jq -- -r '.locks.nodes[] | select(.original.owner) | "\(.original.owner) \(.original.repo)"' flake-meta.json)
          
          if [[ $untrusted_count -gt 0 ]]; then
            echo "‚ùå $untrusted_count untrusted inputs found"
            exit 1
          fi
          
          echo "‚úÖ All security checks passed"

      - name: Build NixOS configuration
        if: matrix.check-type == 'build'
        id: build-info
        run: |
          echo "üèóÔ∏è Building NixOS configuration..."
          
          # Check if blazar config exists first
          has_blazar=$(nix eval --raw --expr 'builtins.hasAttr "blazar" (builtins.getFlake ".").nixosConfigurations' || echo false)
          if [[ "$has_blazar" != "true" ]]; then
            echo "‚ÑπÔ∏è No blazar configuration found, skipping build"
            exit 0
          fi
          
          # Build system configuration with security restrictions
          nix build \
            .#nixosConfigurations.blazar.config.system.build.toplevel \
            --show-trace \
            --option sandbox true \
            --option max-silent-time 600 \
            --option timeout 1800
          
          echo "‚úÖ System configuration built successfully"
          
          # Show build info and prepare artifact
          build_info=$(nix path-info --json result | nix run nixpkgs#jq -- -r '.[] | "Size: \(.narSize) bytes, Hash: \(.narHash)"')
          echo "$build_info"
          
          # Create build artifact
          artifact_name="nixos-build-$(date +%Y%m%d-%H%M%S)"
          echo "artifact-name=$artifact_name" >> "$GITHUB_OUTPUT"
          
          # Store build metadata
          mkdir -p build-artifacts
          echo "$build_info" > "build-artifacts/build-info.txt"
          nix path-info --json result > "build-artifacts/path-info.json"

      - name: Upload build artifacts
        if: matrix.check-type == 'build' && steps.build-info.outputs.artifact-name
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        with:
          name: ${{ steps.build-info.outputs.artifact-name }}
          path: build-artifacts/
          retention-days: 7

      - name: Run validation checks
        if: matrix.check-type == 'checks'
        run: |
          echo "‚úÖ Running validation checks..."
          
          # Check if checks are available
          if ! nix eval --json .#checks.x86_64-linux >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è No validation checks found, skipping"
            exit 0
          fi
          
          # Run all available checks
          nix build .#checks.x86_64-linux --show-trace
          
          echo "‚úÖ All checks passed"

      - name: Quick security scan
        if: matrix.check-type == 'security'
        run: |
          echo "üîç Running security scan..."
          
          # Check if blazar config exists first
          has_blazar=$(nix eval --raw --expr 'builtins.hasAttr "blazar" (builtins.getFlake ".").nixosConfigurations' || echo false)
          if [[ "$has_blazar" != "true" ]]; then
            echo "‚ÑπÔ∏è No blazar configuration found, skipping security scan"
            exit 0
          fi
          
          # Build system for scanning
          nix build .#nixosConfigurations.blazar.config.system.build.toplevel
          system_path=$(readlink -f result)
          
          # Quick vulnerability check
          if command -v vulnix >/dev/null 2>&1; then
            vulnix --system x86_64-linux "$system_path" || echo "‚ö†Ô∏è Vulnerabilities found (non-blocking in CI)"
          else
            nix run nixpkgs#vulnix -- --system x86_64-linux "$system_path" || echo "‚ö†Ô∏è Vulnerabilities found (non-blocking in CI)"
          fi

  # Parallel code quality checks
  code-quality:
    runs-on: ubuntu-latest
    needs: [changes, validate-and-check]
    if: always() && (needs.changes.outputs.nix-files == 'true' || needs.changes.outputs.scripts == 'true' || needs.changes.outputs.docs == 'true' || needs.changes.outputs.workflows == 'true' || needs.changes.outputs.configs == 'true')
    timeout-minutes: 20
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        check-type: [formatting, linting, scripts, docs, workflows, devenv]
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false

      - name: Install Determinate Nix
        uses: DeterminateSystems/determinate-nix-action@a7e500c712ad97316904566d98013596e868d2fb # v3.11.1

      - name: Setup Magic Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@87b14cf437d03d37989d87f0fa5ce4f5dc1a330b # v8

      - name: Setup devenv cache
        uses: cachix/cachix-action@18cf96c7c98e048e10a83abd92116114cd8504be # v14
        with:
          name: devenv

      - name: Cache devenv shells
        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9 # v4.0.2
        with:
          path: |
            ~/.cache/devenv
            ~/.local/share/devenv
          key: devenv-${{ runner.os }}-${{ hashFiles('flake.lock', 'modules/flake/devenvs/**/*.nix') }}
          restore-keys: |
            devenv-${{ runner.os }}-

      - name: Install devenv
        run: nix profile install nixpkgs#devenv

      # IMPROVED: Enhanced formatting checks
      - name: Check code formatting
        if: matrix.check-type == 'formatting' && needs.changes.outputs.nix-files == 'true'
        run: |
          echo "üé® Checking code formatting..."
          
          # Try treefmt first (modern approach)
          if nix build .#formatter --show-trace 2>/dev/null; then
            echo "Using treefmt formatter"
            if ! ./result/bin/treefmt --check --no-cache .; then
              echo "‚ùå Code formatting issues found. Run 'nix fmt' to fix."
              exit 1
            fi
          else
            echo "Using alejandra fallback"
            if ! nix run nixpkgs#alejandra -- --check .; then
              echo "‚ùå Code formatting issues found. Run 'nix run nixpkgs#alejandra -- .' to fix."
              exit 1
            fi
          fi

      - name: Lint Nix code
        if: matrix.check-type == 'linting' && needs.changes.outputs.nix-files == 'true'
        run: |
          echo "üîç Running Nix linters..."
          
          # Check for dead code
          if command -v deadnix >/dev/null 2>&1; then
            deadnix --fail --exclude flake.nix .
          else
            nix run nixpkgs#deadnix -- --fail --exclude flake.nix .
          fi
          
          # Static analysis
          if command -v statix >/dev/null 2>&1; then
            statix check .
          else
            nix run nixpkgs#statix -- check .
          fi

      # ENHANCED: Better shell script checking
      - name: Check shell scripts
        if: matrix.check-type == 'scripts' && needs.changes.outputs.scripts == 'true'
        run: |
          echo "üêö Checking shell scripts..."
          
          shopt -s globstar nullglob
          scripts=(**/*.sh **/scripts/* **/**/scripts/*)
          
          if [[ ${#scripts[@]} -gt 0 ]]; then
            # Check syntax and style
            nix run nixpkgs#shellcheck -- "${scripts[@]}"
            nix run nixpkgs#shfmt -- -d "${scripts[@]}"
            echo "‚úÖ All shell scripts passed checks"
          else
            echo "‚ÑπÔ∏è No shell scripts found"
          fi

      # ENHANCED: Document validation
      - name: Validate documentation
        if: matrix.check-type == 'docs' && needs.changes.outputs.docs == 'true'
        run: |
          echo "üìö Validating documentation..."
          
          # Check markdown files
          if find . -name "*.md" -not -path "./.git/*" | head -1 | read -r; then
            find . -name "*.md" -not -path "./.git/*" -exec nix run nixpkgs#markdownlint-cli -- {} +
          fi
          
          # Check YAML files
          if find . -name "*.yml" -o -name "*.yaml" -not -path "./.git/*" | head -1 | read -r; then
            nix run nixpkgs#yamllint -- .
          fi

      # ENHANCED: GitHub Actions validation
      - name: Validate GitHub Actions
        if: matrix.check-type == 'workflows' && needs.changes.outputs.workflows == 'true'
        run: |
          echo "‚öôÔ∏è Validating GitHub Actions..."
          nix run nixpkgs#actionlint

      # DEVENV: Test development environments
      - name: Test devenv shells
        if: matrix.check-type == 'devenv' && needs.changes.outputs.nix-files == 'true'
        run: |
          echo "üß™ Testing devenv development environments..."
          
          # Test that devenv can build the shells
          echo "Testing default shell..."
          if nix develop --no-pure-eval --command echo "Default shell works"; then
            echo "‚úÖ Default shell builds successfully"
          else
            echo "‚ùå Default shell failed to build"
            exit 1
          fi
          
          # Test language-specific shells
          for shell in python rust zig julia; do
            echo "Testing $shell shell..."
            if timeout 60 nix develop --no-pure-eval .#$shell --command echo "$shell shell works"; then
              echo "‚úÖ $shell shell builds successfully"
            else
              echo "‚ùå $shell shell failed to build"
              exit 1
            fi
          done
          
          # Test devenv CLI integration
          echo "Testing devenv CLI..."
          if devenv test; then
            echo "‚úÖ devenv test passed"
          else
            echo "‚ùå devenv test failed"
            exit 1
          fi

  # CI summary
  ci-summary:
    runs-on: ubuntu-latest
    needs: [changes, validate-and-check, code-quality]
    if: always()
    permissions:
      contents: read
    steps:
      - name: Download build artifacts
        if: needs.validate-and-check.outputs.build-artifact
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          name: ${{ needs.validate-and-check.outputs.build-artifact }}
          path: build-artifacts/

      - name: Generate CI summary
        run: |
          {
            echo "# üéØ Optimized CI Pipeline Summary"
            echo ""
            echo "## üöÄ Performance Improvements"
            echo "- ‚úÖ **Matrix Strategy**: Parallel execution of validation and checks"
            echo "- ‚úÖ **Smart Caching**: Nix store and devenv shells cached between runs"
            echo "- ‚úÖ **Conditional Execution**: Jobs run only when relevant files change"
            echo "- ‚úÖ **Workflow Artifacts**: Build results shared between jobs"
            echo "- ‚úÖ **Parallel Quality Checks**: Independent checks run simultaneously"
            echo ""
            echo "## üìä Change Detection Results"
            echo "- **Nix files**: ${{ needs.changes.outputs.nix-files == 'true' && 'üîÑ Changed' || '‚è≠Ô∏è No changes' }}"
            echo "- **Documentation**: ${{ needs.changes.outputs.docs == 'true' && 'üîÑ Changed' || '‚è≠Ô∏è No changes' }}"
            echo "- **Workflows**: ${{ needs.changes.outputs.workflows == 'true' && 'üîÑ Changed' || '‚è≠Ô∏è No changes' }}"
            echo "- **Scripts**: ${{ needs.changes.outputs.scripts == 'true' && 'üîÑ Changed' || '‚è≠Ô∏è No changes' }}"
            echo "- **Configs**: ${{ needs.changes.outputs.configs == 'true' && 'üîÑ Changed' || '‚è≠Ô∏è No changes' }}"
            echo ""
            echo "## ‚úÖ Validation Results"
            echo "- **Combined Validation**: ${{ needs.validate-and-check.result == 'success' && '‚úÖ Passed' || needs.validate-and-check.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}"
            echo "- **Code Quality**: ${{ needs.code-quality.result == 'success' && '‚úÖ Passed' || needs.code-quality.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}"
            echo ""
            
            # Show build artifact info if available
            if [[ -f "build-artifacts/build-info.txt" ]]; then
              echo "## üèóÔ∏è Build Information"
              cat build-artifacts/build-info.txt
              echo ""
            fi
            
            echo "## üîí Security Features"
            echo "- ‚úÖ SHA-pinned actions (supply chain security)"
            echo "- ‚úÖ Secure runner configuration"
            echo "- ‚úÖ Minimal permissions (RBAC)"
            echo "- ‚úÖ Sandboxed Nix builds"
            echo "- ‚úÖ Dependency validation"
            echo "- ‚úÖ Vulnerability scanning"
            echo "- ‚úÖ Smart caching with integrity checks"
            echo ""
            
            # Overall status
            if [[ "${{ needs.validate-and-check.result }}" == "success" && ("${{ needs.code-quality.result }}" == "success" || "${{ needs.code-quality.result }}" == "skipped") ]]; then
              echo "üéâ **Overall Status**: All checks passed! Pipeline optimized for speed and efficiency."
            else
              echo "‚ö†Ô∏è **Overall Status**: Some checks failed - review required"
            fi
            echo ""
            echo "---"
            echo "*Optimized CI pipeline with matrix strategy, smart caching, and conditional execution*"
          } >> "$GITHUB_STEP_SUMMARY"
